{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, NgModule } from '@angular/core';\nimport firebase from 'firebase/app';\nimport { of, EMPTY, throwError, Observable, concat } from 'rxjs';\nimport { subscribeOn, observeOn, switchMap, map, shareReplay, switchMapTo, catchError, mergeMap, defaultIfEmpty } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵfetchInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nconst proxyPolyfillCompat = {\n  deleteToken: null,\n  getToken: null,\n  onMessage: null,\n  onBackgroundMessage: null,\n  onTokenRefresh: null,\n  requestPermission: null,\n  setBackgroundMessageHandler: null,\n  useServiceWorker: null,\n  usePublicVapidKey: null\n};\nconst VAPID_KEY = /*#__PURE__*/new InjectionToken('angularfire2.messaging.vapid-key');\nconst SERVICE_WORKER = /*#__PURE__*/new InjectionToken('angularfire2.messaging.service-worker-registeration'); // SEMVER(7): drop\n\nconst firebaseLTv8 = /*#__PURE__*/parseInt(firebase.SDK_VERSION, 10) < 8;\nlet AngularFireMessaging = /*#__PURE__*/(() => {\n  class AngularFireMessaging {\n    constructor(options, nameOrConfig, // tslint:disable-next-line:ban-types\n    platformId, zone, vapidKey, _serviceWorker) {\n      const schedulers = new ɵAngularFireSchedulers(zone);\n      const serviceWorker = _serviceWorker;\n      const messaging = of(undefined).pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => isPlatformServer(platformId) ? EMPTY : import('firebase/messaging')), map(() => ɵfirebaseAppFactory(options, zone, nameOrConfig)), switchMap(app => ɵfetchInstance(`${app.name}.messaging`, 'AngularFireMessaging', app, () => __awaiter(this, void 0, void 0, function* () {\n        const messaging = app.messaging();\n\n        if (firebaseLTv8) {\n          if (vapidKey) {\n            messaging.usePublicVapidKey(vapidKey);\n          }\n\n          if (serviceWorker) {\n            messaging.useServiceWorker(yield serviceWorker);\n          }\n        }\n\n        return messaging;\n      }), [vapidKey, serviceWorker])), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      this.requestPermission = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), // tslint:disable-next-line\n      switchMap(messaging => firebase.messaging.isSupported() ? messaging.requestPermission() : throwError('Not supported.')));\n      this.getToken = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => __awaiter(this, void 0, void 0, function* () {\n        if (firebase.messaging.isSupported() && Notification.permission === 'granted') {\n          if (firebaseLTv8) {\n            return yield messaging.getToken();\n          } else {\n            const serviceWorkerRegistration = serviceWorker ? yield serviceWorker : null;\n            return yield messaging.getToken({\n              vapidKey,\n              serviceWorkerRegistration\n            });\n          }\n        } else {\n          return null;\n        }\n      })));\n      const notificationPermission$ = new Observable(emitter => {\n        navigator.permissions.query({\n          name: 'notifications'\n        }).then(notificationPerm => {\n          notificationPerm.onchange = () => emitter.next();\n        });\n      });\n      const tokenChange$ = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMapTo(notificationPermission$), switchMapTo(this.getToken));\n      this.tokenChanges = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => firebase.messaging.isSupported() ? concat(this.getToken, tokenChange$) : EMPTY));\n      this.messages = messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => firebase.messaging.isSupported() ? new Observable(emitter => messaging.onMessage(next => emitter.next(next), err => emitter.error(err), () => emitter.complete())) : EMPTY));\n      this.requestToken = of(undefined).pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(() => this.requestPermission), catchError(() => of(null)), mergeMap(() => this.tokenChanges)); // SEMVER(7): drop token\n\n      this.deleteToken = token => messaging.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), switchMap(messaging => messaging.deleteToken(token || undefined)), defaultIfEmpty(false));\n\n      return ɵlazySDKProxy(this, messaging, zone);\n    }\n\n  }\n\n  AngularFireMessaging.ɵfac = function AngularFireMessaging_Factory(t) {\n    return new (t || AngularFireMessaging)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(VAPID_KEY, 8), ɵngcc0.ɵɵinject(SERVICE_WORKER, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireMessaging.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AngularFireMessaging_Factory() {\n      return new AngularFireMessaging(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(VAPID_KEY, 8), i0.ɵɵinject(SERVICE_WORKER, 8));\n    },\n    token: AngularFireMessaging,\n    providedIn: \"any\"\n  });\n  /** @nocollapse */\n\n  return AngularFireMessaging;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireMessaging, [proxyPolyfillCompat]);\nlet AngularFireMessagingModule = /*#__PURE__*/(() => {\n  class AngularFireMessagingModule {}\n\n  AngularFireMessagingModule.ɵfac = function AngularFireMessagingModule_Factory(t) {\n    return new (t || AngularFireMessagingModule)();\n  };\n\n  AngularFireMessagingModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireMessagingModule\n  });\n  AngularFireMessagingModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireMessaging]\n  });\n  return AngularFireMessagingModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireMessaging, AngularFireMessagingModule, SERVICE_WORKER, VAPID_KEY }; //# sourceMappingURL=angular-fire-messaging.js.map","map":null,"metadata":{},"sourceType":"module"}